#!/usr/bin/env ruby

require 'gli'
require 'trickster'
require 'erb'
require 'fileutils'

include GLI::App

BASE_DIR = File.expand_path(File.join(File.dirname(__FILE__),'..'))

THEMES = Dir[File.join(BASE_DIR,'css','themes') + "/*.css",
             File.join(BASE_DIR,'css','themes') + "/*.scss"].map { |file| 
  File.basename(file).gsub(/\.css$/,'').gsub(/\.scss/,'') 
}.sort

program_desc 'Bootstrap, generate, and manage your trickster presentation'

version Trickster::VERSION

def add_theme_flag(command)
  command.desc "Specify the syntax highlighting theme to use.  One of #{THEMES.join(', ')}.  Use 'custom' to get an scss file you can easily customize."
  command.default_value 'default'
  command.flag [:t,:theme], :must_match => THEMES
end

desc 'Create a new trickster presentation'
long_desc <<EOS
This will create a completely self-contained presentation that can be run just from the files
in the directory you name.  It will have a static copy of the JavaScript files, JavaScript third-party
libraries and CSS files you need to run your trickster application.

You can examine the file `slides` to see some examples of how to format your
presentation.  You can run `trickster build` in the directory to create the HTML
file from your slides.

Note that if you upgrade trickster, you should run `trickster update` in your slide directory
to get the latest JavaScript and CSS files.
EOS
arg_name 'dir_name'
command :init do |c|

  add_theme_flag(c)

  c.action do |global_options,options,args|
    dir = args.shift
    FileUtils.mkdir(dir)
    File.open(File.join(dir,'slides'),'w') do |file|
      file.puts <<EOF
Title of your slideshow
!TITLE
Title of your slideshow
Subtitle
Sub-sub title

!SECTION: background=dddddd
A section

!BULLETS
A bullet list
* can use any
- reasonable
+ bullet

!CODE: callout=3,4,5
class YourCode

  def initialize(will)
    @be_highlighted
  end

end
EOF

      file_copier = Trickster::FileCopier.new(BASE_DIR,dir)
      file_copier.copy_files('js','js')
      file_copier.copy_files('js/lib','js')
      file_copier.copy_files('css','css')

      theme_copier = Trickster::ThemeCopier.new(BASE_DIR,dir)
      theme_copier.copy_theme(options[:theme])

      puts "Your slideshow is ready, cd to #{BASE_DIR} and run `trickster build`, then open index.html"
    end
  end
end

desc 'Update your slideshow with files provided by trickster'
arg_name '[dir_name]'
command :update do |c|

  c.desc "Update the trickster JS/CSS files when you've updated the trickster gem"
  c.long_desc <<-EOS
  Run this after you've upgraded trickster and want to get the latest features.  Since your 
  slideshow is entirely self-contained, when you upgrade trickster, your static JavaScript and
  CSS files will be out of date.

  Note that `styles.css`, which was provided by trickster as a basis for styling, will not
  be touched, and your customizations will remain. All other files that trickster gave you
  when you ran `trickster init` will be overwritten.
  EOS
  c.arg_name 'slide_dir'
  c.command :files do |files_command|
    files_command.action do |global_options,options,args|
      dir = args.shift
      dir = '.' if dir.nil?

      copier = Trickster::FileCopier.new(BASE_DIR,dir)
      copier.copy_files('js','js', :except => "custom.js")
      copier.copy_files('js/lib','js')
      copier.copy_files('css','css', :except => "styles.css")
    end
  end

  c.desc 'Update the syntax-highlighting theme for your presentation'
  c.long_desc <<-EOS
  A normal 'trickster update' will leave your theme.css alone, since you can customize it.  This will overwrite
  your existing theme.css with the theme from trickster that you specify.  You should check your presentation
  into source control to avoid the destructive nature of this command.
  EOS
  c.arg_name 'slide_dir'
  c.command :theme do |theme_command|
    add_theme_flag(theme_command)

    theme_command.action do |global_options,options,args|
      dir = args.shift
      dir = '.' if dir.nil?
      theme_copier = Trickster::ThemeCopier.new(BASE_DIR,dir)
      theme_copier.copy_theme(options[:theme])
    end
  end

  c.default_command :files
end

desc 'Serve your presentation on a local port'
long_desc <<EOS
If using TypeKit, you'll need to actually run your presentation on a web server so the fonts will be downloaded.  This is an easy way to do that without having to mess with any other gems, libraries, or configuration.
EOS
command :serve do |c|
  c.desc          'Port on which to run'
  c.arg_name      'port'
  c.default_value '9090'
  c.flag          [:p,:port]

  c.action do |global_options,options,args|
    command = "ruby -run -e httpd . -p #{options[:port]}"
    unless system(command)
      STDERR.puts "Problem running '#{command}'"
    end
  end

end

desc 'Generate the presentation from your slides'
arg_name '[slides_file]'
long_desc <<EOS
Given your slides_file (defaults to 'slides' in current directory), generates an HTML file (based on --output-file) that, when loaded, can be used to play your presentation.

Any .scss files found in the css/ directory will be run through SASS to be converted.

Note that currently, the CSS and JS files included are fixed, so keep all your customizations to styles.css/styles.scss and custom.js (these files will not be overwritten when you do a trickster update).
EOS
command :build do |c|
  c.desc          'Name of the generated HTML file'
  c.arg_name      'file'
  c.default_value 'index.html'
  c.flag          [:o,'output-file']
  
  c.desc          'Your TypeKit ID, if using TypeKit'
  c.arg_name      'id'
  c.flag          [:t,'type-kit-id']

  c.action do |global_options,options,args|
    file    = File.open(args.shift || 'slides')
    css_dir = File.join(File.dirname(file),'css')
    lines   = file.readlines.map(&:chomp)
    parser  = Trickster::SlideParser.new(lines,Trickster::SlideRenderer.new)
    body    = parser.body
    title   = parser.title

    typekit_id = options[:'type-kit-id']

    erb = ERB.new(File.new(File.expand_path(File.join(File.dirname(__FILE__),'..','erb','index.html.erb'))).readlines.join(""))
    File.open(options[:'output-file'],"w") do |file|
      file.puts erb.result(binding)
    end
    Dir["#{css_dir}/*.scss"].each do |sass_file|
      css_file = sass_file.gsub(/\.scss$/,'.css')
      command = "sass #{sass_file} #{css_file}"
      unless system(command)
        STDERR.puts "Problem running '#{command}'"
      end
    end

    puts "Note that typekit won't work unless you serve your presentation via a web server" if typekit_id
  end
end

exit run(ARGV)
